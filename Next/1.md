# Next.js Interview Questions & Answers (Advanced to FAANG Level)

### 1. What is the difference between Pages Router and App Router?

Answer (Interview style):
Pages Router is the old file-based system using pages/, whereas App Router is the new React Server Component–based architecture under app/. App Router gives automatic server-side rendering, server components, nested layouts, streaming, React 18 features, and server actions. The Pages Router is mostly client-side React, while App Router defaults to server-first.

### 2. What exactly are React Server Components (RSC) in Next.js?

Answer:
React Server Components allow React logic to run on the server by default. They don't ship JavaScript to the browser unless needed. In Next.js, everything in app/ is a server component unless marked 'use client'. This reduces bundle size, improves TTFB, and avoids unnecessary hydration.

### 3. When should you use 'use client'?

Answer:
I only use 'use client' when the component needs browser APIs or interactivity — like event listeners, useState, useEffect, useRef, context providers, or a UI library like Chakra/Material UI.
Otherwise I keep components server-side for performance.

### 4. What are Server Actions in Next.js?

Answer:
Server Actions let me run server-side code directly from a client component or a form without creating an API route. They are async functions marked 'use server'. They remove the need for REST endpoints for typical mutations and allow secure, validated, server-side logic with client-side calls.

### 5. How is data fetching different in App Router?

Answer:
In App Router, data fetching is server-first. I can fetch directly inside a server component using async/await.
Next.js automatically caches the request unless I opt out using cache: 'no-store' or revalidate.
So fetching is simpler, faster, and streamed.

### 6. What are fetch caching and revalidation in Next.js?

Answer:
Next.js wraps fetch with smart caching.
* By default it caches like cache: 'force-cache'.
* I can control revalidation using revalidate: X for ISR.
* I can opt out using cache: 'no-store'.
Next.js also supports route-level caching using revalidatePath and revalidateTag.

### 7. What is Route Handlers vs API Routes?

Answer:
API Routes belong to the older Pages Router.
Route Handlers (app/api/.../route.ts) are the App Router equivalent but support streaming, WebStreams, edge runtime, and better integration with server components.

### 8. How does Next.js handle streaming UI?

Answer:
Next.js uses React 18’s streaming SSR. It sends the shell immediately and then progressively streams in server component chunks.
This improves TTFB and allows Suspense boundaries to progressively hydrate.

### 9. What is the difference between SSR, SSG, ISR in Next.js?

Answer:
* SSR: Page is rendered on every request (cache: 'no-store').
* SSG: Page is fully static at build time (export const revalidate = false).
* ISR: Page is revalidated periodically in the background (revalidate = X).

Interview answer:
ISR is basically SSG with timed regeneration.

### 10. What is the folder structure in App Router?

Answer:
* layout.tsx → persistent UI wrapper
* page.tsx → actual route
* loading.tsx → suspense fallback
* error.tsx → error boundary
* not-found.tsx → 404
* route.ts → API/Route handlers
* template.tsx → re-render on navigation

### 11. Explain Next.js Middleware.

Answer:
Middleware runs before the request hits a route. It's useful for authentication, redirects, AB testing, geo-based routing, feature flags, and bot protection. It runs on the Edge runtime, so it's extremely fast.

### 12. When should you choose Edge Runtime?

Answer:
I use Edge Runtime when I need low-latency global performance — for example, geolocation-based personalization or auth checks.
But I avoid it when I need Node APIs, large dependencies, or DB drivers not supported by Edge.

### 13. How does Next.js optimize images?

Answer:
* next/image performs:
* lazy loading
* intelligent resizing
* AVIF/WebP
* responsive sizes
* placeholder blur
* automatic CDN caching
It drastically reduces bandwidth and improves LCP.

### 14. Explain Optimistic UI in Next.js with Server Actions.

Answer:
Using useOptimistic, I can update the UI immediately before the server action finishes. If the server response fails, I roll back the change.
This makes interactions feel instant.

### 15. How does Turbopack differ from Webpack?

Answer:
Turbopack is Rust-based and massively faster than Webpack.
It has incremental compilation, instant HMR, and better cold-start speeds.
Next.js is shifting to Turbopack as the default dev bundler.

### 16. What is the difference between useRouter (app) vs (pages)?

Answer:
* Pages router: useRouter() from next/router.
* App router: useRouter() from next/navigation (client only).
App Router’s router is more lightweight and supports server-refresh and soft navigation.

### 17. How do you handle authentication in Next.js?

Answer:
* Middleware for route protection
* Server Actions for login
* Route Handlers for token issuance
* Protected layouts
* Integration with NextAuth or custom auth flow

### 18. Deployment Platforms?

Answer:
I typically deploy on Vercel because Next.js is optimized for it — edge functions, caching, ISR, image optimization.
But I can deploy on AWS, GCP, Docker, or any Node server using next start.

### 19. How does Dynamic Rendering work in App Router?

Answer:
Next.js determines rendering based on your fetch settings:
* no-store → fully dynamic
* revalidate → ISR
* force-cache → static
You control rendering per component.

### 20. What’s new in Next.js 15?

Answer:
* Faster server actions
* Fetch replays
* Partial prerendering
* Improved turbopack
* More stable app router
* New next() APIs for middleware
* More flexible caching controls